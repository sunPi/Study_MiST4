install.packages(c("emmeans", "pkgload", "XML"))
path <- "/home/jan1/bioinf-tools/pipelines/Shared/parp-pipe/src/MesoXGBoost/outfolder/relative_0.1_150_development/robj/pipe.data.RDS"
mb.data <- readRDS(path)
mb.data <- select(mb.data$abun_species.relative, c("Oscillibacter_sp.", "Parabacteroides_distasonis", "Alistipes_indistinctus"))
mb.data <- dplyr::select(mb.data$abun_species.relative, c("Oscillibacter_sp.", "Parabacteroides_distasonis", "Alistipes_indistinctus"))
mb.data
sel <- dplyr::select(mb.data$abun_species.relative, c("Oscillibacter_sp.", "Parabacteroides_distasonis", "Alistipes_indistinctus"))
mb.data <- readRDS(path)
sel <- dplyr::select(mb.data$abun_species.relative, c("Oscillibacter_sp.", "Parabacteroides_distasonis", "Alistipes_indistinctus"))
mb.data <- data.frame(mb.data$abun_species.relative[1:4], sel)
mb.data
# Transform character data into numeric (binary 0,1)
mb.data$response[mb.data$response %in% "G"] <- 0 # Growth is coded as 0
mb.data$response[mb.data$response %in% "R"] <- 1 # Reduction is coded as 1
mb.data$response <- as.numeric(mb.data$response) # Ensure numbers are actually numeric data types
mutate(mb.data$Parabacteroides_distasonis/(mb.data$Oscillibacter_sp.+mb.data$Alistipes_indistinctus))
dplyr::mutate(mb.data$Parabacteroides_distasonis/(mb.data$Oscillibacter_sp.+mb.data$Alistipes_indistinctus))
dplyr::mutate(mb.data, Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus))
dplyr::mutate(mb.data, "3-way_ratio" = Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus))
dplyr::transmute(mb.data, "3-way_ratio" = Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus))
mb.data <- data.frame(mb.data$abun_species.relative[1:4], dplyr::transmute(mb.data, "3-way_ratio" = Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus)))
dplyr::transmute(mb.data, "3-way_ratio" = Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus))
dplyr::transmute(mb.data, "3-way_ratio" = (Parabacteroides_distasonis)/(Oscillibacter_sp.+Alistipes_indistinctus))
mb.data
mb.data <- data.frame(mb.data$abun_species.relative[1:4], dplyr::transmute(mb.data, "3-way_ratio" = Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus)))
ratio <- dplyr::transmute(mb.data, "3-way_ratio" = (Parabacteroides_distasonis)/(Oscillibacter_sp.+Alistipes_indistinctus))
ratio
mb.data
mb.data <- data.frame(mb.data$abun_species.relative[1:4], ratio)
mb.data <- data.frame(mb.data[1:4], ratio)
mb.data$ratio_alistipes_parabacteroides <- log(mb.data$ratio_alistipes_parabacteroides) # Transform data using log function
ratio <- dplyr::transmute(mb.data, "3-way_ratio" = log(Parabacteroides_distasonis)/(Oscillibacter_sp.+Alistipes_indistinctus))
ratio
ratio <- dplyr::transmute(mb.data, "3-way_ratio" = (Parabacteroides_distasonis)/(Oscillibacter_sp.+Alistipes_indistinctus))
mb.data <- readxl::read_excel(path)
mb.data <- readRDS(path)
sel <- dplyr::select(mb.data$abun_species.relative, c("Oscillibacter_sp.", "Parabacteroides_distasonis", "Alistipes_indistinctus"))
ratio <- dplyr::transmute(sel, "3-way_ratio" = (Parabacteroides_distasonis)/(Oscillibacter_sp.+Alistipes_indistinctus))
ratio
ratio <- dplyr::transmute(sel, "3-way_ratio" = log(Parabacteroides_distasonis)/(Oscillibacter_sp.+Alistipes_indistinctus))
ratio
ratio <- dplyr::transmute(sel, "3-way_ratio" = log(Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus))
ratio
ratio
sel <- dplyr::select(mb.data$abun_species.relative, c("Oscillibacter_sp.", "Parabacteroides_distasonis", "Alistipes_indistinctus"))
ratio <- dplyr::transmute(sel, "3-way_ratio" = log(Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus))
ratio
ratio
ratio <- dplyr::transmute(sel, "3-way_ratio" = log(Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus)))
ratio
ratio <- dplyr::transmute(sel, "3-way_ratio" = log(Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus)))
ratio
ratio <- dplyr::transmute(sel, "3-way_ratio" = Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus))
ratio
ratio[20]
ratio[[20]]
ratio[1]
ratio$`3-way_ratio`[20]
mb.data <- readRDS(path)
sel <- dplyr::select(mb.data$abun_species.relative, c("Oscillibacter_sp.", "Parabacteroides_distasonis", "Alistipes_indistinctus"))
ratio <- dplyr::transmute(sel, "3-way_ratio" = Parabacteroides_distasonis/(Oscillibacter_sp.+Alistipes_indistinctus))
ratio
ratio$`3-way_ratio`[20] <- 0.0000000
raito
rati
ratio
log(raio)
log(ratio)
ratio
sel
#------------ Logistic Regression For Biomarker Predictive Power ---------------
# Test the predictive power of the ratio of log10(Alistipes_indistinctus/Parabacteroides_distasonis)
path <- "ratio.xlsx" # This is your file with your ratios
mb.data <- readxl::read_excel(path)
getcwd()
getwd()
#------------ Logistic Regression For Biomarker Predictive Power ---------------
# Test the predictive power of the ratio of log10(Alistipes_indistinctus/Parabacteroides_distasonis)
path <- "../datasets/ratio.xlsx" # This is your file with your ratios
mb.data <- readxl::read_excel(path)
mb.data
# Transform character data into numeric (binary 0,1)
mb.data$response[mb.data$response %in% "G"] <- 0 # Growth is coded as 0
mb.data$response[mb.data$response %in% "R"] <- 1 # Reduction is coded as 1
mb.data$response <- as.numeric(mb.data$response) # Ensure numbers are actually numeric data types
names(mb.data)[3] <- "ratio_alistipes_parabacteroides" # Name the column
mb.data$ratio_alistipes_parabacteroides <- log(mb.data$ratio_alistipes_parabacteroides) # Transform data using log function
# split <- sampleDataset(mb.data, 0.7)
# tr.id <- which(mb.data$`MIST ID` %in% split$train$`MIST ID`)
# m <- glm(response ~ ratio_alistipes_parabacteroides, data = mb.data, subset = tr.id, family = "binomial")
# pp <- predict(m, newdata = split$test,  type = "response")
# labels <- split$test$response
# predictions <- as.numeric(pp > 0.2)
m <- glm(response ~ ratio_alistipes_parabacteroides, data = mb.data, family = "binomial") # Use 'glm()' from native R to create a model of f(x) = an + b
pp <- predict(m, type = "response") # Use the fitted model to predict and generate prediction probabilities
labels <- mb.data$response
sort(pp)
predictions <- as.numeric(pp > 0.3) # Define a threshold to transform probabilits into discrete predictions (default 0.5)
roc.obj <- pROC::roc(mb.data$response, pp) # Create a ROC object
pROC::plot.roc(roc.obj, print.auc = TRUE, main = "ROC-AUC Curve of a Logistic Regression model \n for the log(Alistipes/Parabacteroides) Ratio",
cex.axis = 1.8, cex.lab = 1.8, cex.main = 1.3, col = "red") # plot a ROC curve based on the ROC analysis
rocobj <- pROC::roc(mb.data$response, mb.data$ratio_alistipes_parabacteroides, smooth=TRUE)
pROC::ci.auc(roc.obj, conf.level = 0.95) # 95 % CI
pROC::ci.auc(roc.obj, conf.level = 0.99) # 99% CI
pROC::plot.roc(rocobj, print.auc = TRUE, main = "ROC-AUC Curve of a Logistic Regression model \n for the log(Alistipes/Parabacteroides) Ratio",
cex.axis = 1.8, cex.lab = 1.8, cex.main = 1.3, col = "red") # Smooth ROC AUC Curve
rocobj$sensitivities
rocobj$specificities
rocobj$model
rocobj$percent
rocobj$auc
rocobj$sensitivities
rocobj$specificities
length(rocobj$sensitivities)
length(rocobj$specificities)
rocobj$sensitivities
rocobj$sensitivities[91]
rocobj$specificities[91]
rocobj$sensitivities[91]
rocobj$specificities[91]
0.825831703/0.8369759
tpr <- rocobj$sensitivities[91]
tpr <- rocobj$sensitivities[91]
fpr <- 1 - rocobj$specificities[91]
tpr - (1-fpr)
fpr
tpr
fpr
tpr - fpr
gmeans = sqrt(tpr * (1-fpr))
gmeans
gmeans = sqrt(tpr * fpr)
gmeans
# Calculate the Threshold Automatically
gmeans <- sqrt(rocobj$sensitivities * rocobj$specificities)
gmeans
max(gmeans)
as.numeric(pp > max(gmeans))
ptest <- as.numeric(pp > max(gmeans))
cm <- caret::confusionMatrix(data = as.factor(ptest), reference = as.factor(labels))
cm$overall
ptest <- as.numeric(pp > 0.22)
cm <- caret::confusionMatrix(data = as.factor(ptest), reference = as.factor(labels))
cm$overall
ptest <- as.numeric(pp > 0.3)
cm <- caret::confusionMatrix(data = as.factor(ptest), reference = as.factor(labels))
cm$overall
ptest <- as.numeric(pp > 0.5)
cm <- caret::confusionMatrix(data = as.factor(ptest), reference = as.factor(labels))
cm$overall
# Calculate the Threshold Automatically
gmeans <- sqrt(rocobj$sensitivities * (1- rocobj$specificities))
max(gmeans)
from numpy import sqrt
reticulate::repl_python()
# Calculate the Threshold Automatically
J = rocobj$sensitivities +  rocobj$specificities – 1
# Calculate the Threshold Automatically
J <- rocobj$sensitivities +  rocobj$specificities – 1
gmeans <- sqrt(rocobj$sensitivities * (1- rocobj$specificities))
gmeans <- sqrt(rocobj$sensitivities * (1- rocobj$specificities))
gmeans <- sqrt(rocobj$sensitivities * (1- rocobj$specificities))
# https://machinelearningmastery.com/threshold-moving-for-imbalanced-classification/
# ------------------ Functions -------------------------------------------------
requirements      <- function(pkgs){ # This function checks package requirements and install them if they are missing
suppressMessages(if (!require("BiocManager", character.only = TRUE)) { # First check via R BioConductior
install.packages("BiocManager")
BiocManager::install()
} else {
ipkgs <- sapply(pkgs, function(...) require(..., character.only = TRUE))
if (any(!ipkgs)) {
BiocManager::install(pkgs[!ipkgs])
install.packages(pkgs[!ipkgs])
} else {
message("\n\nCool! your machine has everything is needed.\n\n")
}
})
print("Loading required packages...")
library(pacman)
pacman::p_load(pkgs, install = TRUE, character.only = TRUE) # Check via RCran and other repositories
return(pacman::p_loaded()) # Return loaded packages
} # Helper function for packages & requirements
getYd <- function(cm){
tn <- cm$table[1]
fn <- cm$table[2]
fp <- cm$table[3]
tp <- cm$table[4]
return(cutpointr::youden(tp = tp, fp = fp, tn = tn, fn = fn))
} # Function that calculates the Youden's Index
# ------------------ Solve requirements (make script reusable) ----------------
pkgs <- c('caret', 'pROC') # The 'hilldiv' package requires the installation of
# cmake package on linux. Install via "sudo apt install cmake"
requirements(pkgs) # Call the function
# packageVersion('pROC') # Package versions
#------------ Logistic Regression For Biomarker Predictive Power ---------------
# Test the predictive power of the ratio of log10(Alistipes_indistinctus/Parabacteroides_distasonis)
path <- "../datasets/ratio.xlsx" # This is your file with your ratios
mb.data <- readxl::read_excel(path)
# Transform character data into numeric (binary 0,1)
mb.data$response[mb.data$response %in% "G"] <- 0 # Growth is coded as 0
mb.data$response[mb.data$response %in% "R"] <- 1 # Reduction is coded as 1
mb.data$response <- as.numeric(mb.data$response) # Ensure numbers are actually numeric data types
names(mb.data)[3] <- "ratio_alistipes_parabacteroides" # Name the column
mb.data$ratio_alistipes_parabacteroides <- log(mb.data$ratio_alistipes_parabacteroides) # Transform data using log function
# ------------------ 20-fold Cross Validation ----
# split <- sampleDataset(mb.data, 0.7)
# tr.id <- which(mb.data$`MIST ID` %in% split$train$`MIST ID`)
# m <- glm(response ~ ratio_alistipes_parabacteroides, data = mb.data, subset = tr.id, family = "binomial")
# pp <- predict(m, newdata = split$test,  type = "response")
# labels <- split$test$response
# predictions <- as.numeric(pp > 0.2)
m <- glm(response ~ ratio_alistipes_parabacteroides, data = mb.data, family = "binomial") # Use 'glm()' from native R to create a model of f(x) = an + b
pp <- predict(m, type = "response") # Use the fitted model to predict and generate prediction probabilities
labels <- mb.data$response
sort(pp)
predictions <- as.numeric(pp > 0.3) # Define a threshold to transform probabilits into discrete predictions (default 0.5)
roc.obj <- pROC::roc(mb.data$response, pp) # Create a ROC object
pROC::plot.roc(roc.obj, print.auc = TRUE, main = "ROC-AUC Curve of a Logistic Regression model \n for the log(Alistipes/Parabacteroides) Ratio",
cex.axis = 1.8, cex.lab = 1.8, cex.main = 1.3, col = "red") # plot a ROC curve based on the ROC analysis
rocobj <- pROC::roc(mb.data$response, mb.data$ratio_alistipes_parabacteroides, smooth=TRUE)
# Calculate the Threshold Automatically
J <- rocobj$sensitivities +  rocobj$specificities - 1
J
gmea)ns <- sqrt(rocobj$sensitivities * (1- rocobj$specificities))
max(J)
tpr <- rocobj$sensitivities[91]
fpr <- rocobj$specificities[91]
tpr - fpr
fpr <- 1- rocobj$specificities[91]
tpr - fpr
rocobj$sensitivities[91]
rocobj$sensitivities
rocobj$sensitivities/rocobj$specificities
(rocobj$sensitivities/rocobj$specificities)*100
rocobj$sensitivities/rocobj$specificities
rocobj$specificities
rocobj$specificities
rocobj$sensitivities/rocobj$specificities
rocobj$specificities[0]
rocobj$specificities[1]
rocobj$sensitivities[1]
rocobj$specificities
rocobj$sensitivities
1- rocobj$specificities
rocobj$sensitivities/(1 - rocobj$specificities)
rocobj$sensitivities/rocobj$specificities
rocobj$sensitivities
1 - rocobj$specificities
(1 - rocobj$specificities)[1]
rocobj$sensitivities[1]
rocobj$sensitivities[514]
(1 - rocobj$specificities)[514]
rocobj$sensitivities/(1-rocobj$specificities)
rocobj$sensitivities[514]/(1 - rocobj$specificities)[514]
rocobj$sensitivities[514]
(1 - rocobj$specificities)[514]
0/0
rocobj$sensitivities/(1-rocobj$specificities)
t <- rocobj$sensitivities/(1-rocobj$specificities)
is.na()
is.na(t)
t[is.na(t)] <- 0
t
max(t)
max(t)
t[max(t)]
max(t)
t %in% max(t)
which(t %in% max(t))
rocobj$sensitivities[199]
rocobj$sensitivities[188]
rocobj$specificities[188]
points()
points(rocobj$sensitivities[188], rocobj$specificities[188])
t <- rocobj$sensitivities + rocobj$specificities
t
max(t)
which(t %in% max(t))
points(rocobj$sensitivities[29], rocobj$specificities[29])
t <- rocobj$sensitivities + (1-rocobj$specificities)
which(t %in% max(t))
max(t)
t <- rocobj$sensitivities + (1-rocobj$specificities)
max(t)
which(t %in% max(t))
t[1]
t[2]
points(rocobj$sensitivities[2], rocobj$specificities[2])
t <- rocobj$sensitivities + (rocobj$specificities)
rocobj <- pROC::roc(mb.data$response, mb.data$ratio_alistipes_parabacteroides, smooth=TRUE)
pROC::plot.roc(rocobj, print.auc = TRUE, main = "ROC-AUC Curve of a Logistic Regression model \n for the log(Alistipes/Parabacteroides) Ratio",
cex.axis = 1.8, cex.lab = 1.8, cex.main = 1.3, col = "red") # Smooth ROC AUC Curve
points(rocobj$sensitivities[188], rocobj$specificities[188])
points(rocobj$sensitivities[29], rocobj$specificities[29])
plot.roc
roc.obj$sensitivities
roc.obj$specificities
roc.obj$sensitivities - roc.obj$specificities
roc.obj$sensitivities - (1-roc.obj$specificities)
max(roc.obj$sensitivities - (1-roc.obj$specificities))
which(max(roc.obj$sensitivities - (1-roc.obj$specificities)))
pROC::plot.roc(roc.obj, print.auc = TRUE, main = "ROC-AUC Curve of a Logistic Regression model \n for the log(Alistipes/Parabacteroides) Ratio",
cex.axis = 1.8, cex.lab = 1.8, cex.main = 1.3, col = "red") # plot a ROC curve based on the ROC analysis
roc.obj$sensitivities - (1-roc.obj$specificities)
t <- roc.obj$sensitivities - (1-roc.obj$specificities)
t %in% max(t)
which(t %in% max(t))
points(roc.obj$sensitivities[9], roc.obj$specificities[9])
t <- roc.obj$sensitivities - (roc.obj$specificities)
which(t %in% max(t))
t
t <- roc.obj$sensitivities + (roc.obj$specificities)
which(t %in% max(t))
points(roc.obj$sensitivities[9], roc.obj$specificities[9])
roc.obj$sensitivities
roc.obj$sensitivities %in%  0.72727273
points(roc.obj$sensitivities[11], roc.obj$specificities[9])
roc.obj$specificities
points(roc.obj$sensitivities[11], roc.obj$specificities[1])
points(roc.obj$sensitivities[11], roc.obj$specificities[11])
points(roc.obj$sensitivities[11], roc.obj$specificities[10])
roc.obj <- pROC::roc(mb.data$response, pp) # Create a ROC object
pROC::plot.roc(roc.obj, print.auc = TRUE, main = "ROC-AUC Curve of a Logistic Regression model \n for the log(Alistipes/Parabacteroides) Ratio",
cex.axis = 1.8, cex.lab = 1.8, cex.main = 1.3, col = "red") # plot a ROC curve based on the ROC analysis
roc.obj$specificities
points(roc.obj$sensitivities[11], roc.obj$specificities[1])
roc.obj$sensitivities[11]
points(roc.obj$specificities[1], roc.obj$sensitivities[11])
points(roc.obj$specificities[11], roc.obj$sensitivities[11])
J <- roc.obj$sensitivities +  roc.obj$specificities - 1
J
J <- roc.obj$sensitivities +  (roc.obj$specificities - 1)
J
gmeans <- sqrt(roc.obj$sensitivities * (1- roc.obj$specificities))
max(gmeans)
gmeans
gmeans <- sqrt(roc.obj$sensitivities * (roc.obj$specificities))
max(gmeans)
gmeans
gmeans
which(gmeans %in% max(gmeans))
points(roc.obj$specificities[9], roc.obj$sensitivities[9])
gmeans <- sqrt(roc.obj$sensitivities * (1-roc.obj$specificities))
max(gmeans)
which(gmeans %in% max(gmeans))
gmeans
which(gmeans %in% max(gmeans))
points(roc.obj$specificities[1], roc.obj$sensitivities[1])
roc.obj$thresholds
roc.obj$thresholds[9]
points(roc.obj$specificities[9], roc.obj$sensitivities[9])
roc.obj$thresholds
roc.obj$thresholds[9]
roc.obj$thresholds[3]
# Calculate the Threshold Automatically
dist()
# Calculate the Threshold Automatically
dist(roc.obj$sensitivities)
# Calculate the Threshold Automatically
dist(roc.obj$sensitivities, upper = TRUE)
# Calculate the Threshold Automatically
dist(roc.obj$sensitivities, p = 1)
# Calculate the Threshold Automatically
dist(roc.obj$sensitivities, p = 2)
# Calculate the Threshold Automatically
dist(roc.obj$sensitivities, p = 10)
# Calculate the Threshold Automatically
dist(roc.obj$sensitivities, p = 0.1)
# Calculate the Threshold Automatically
dist(roc.obj$sensitivities, p = 0.1, method = "minkowski")
# Calculate the Threshold Automatically
x <- c(5,6)
y <- c(19,1)
y <- c(19,2)
calc_dist <- function(x,y){
xd <- x[2] - x[1]
yd <- y[2] - y[1]
return(sqrt(xd+yd))
}
calc_dist(x = x, y = y)
y[1]
y[2]
calc_dist <- function(x,y){
xd <- x[2] - x[1]
yd <- y[2] - y[1]
return(sqrt(abs(xd+yd)))
}
calc_dist(x = x, y = y)
calc_dist <- function(x,y){
xd <- (x[2] - x[1])^2
yd <- (y[2] - y[1])^2
return(sqrt(abs(xd+yd)))
}
calc_dist(x = x, y = y)
calc_dist <- function(x,y){
xd <- (x[2] - x[1])^2
yd <- (y[2] - y[1])^2
return(sqrt(xd+yd))
}
calc_dist(x = x, y = y)
roc.obj$percent
roc.obj$sensitivities
roc.obj$specificities
roc.obj$specificities
roc.obj$sensitivities
roc.obj$sensitivities
roc.obj$specificities
length(roc.obj$specificities)
yt <- roc.obj$specificities[length(roc.obj$specificities)]
yt
xt <- roc.obj$sensitivities[1]
xt
yt <- 1
t <- 2
append(t, 3)
t
t <- append(t, 3)
t
t <- append(t, 4)
t <- append(t, 2)
t
xm <- NULL
xm <- NULL
for(x in roc.obj$specificities){
xm <- append(xm, (xt - x)^2)
}
xm
ym <- NULL
for(y in roc.obj$specificities){
ym <- append(ym, (yt - y)^2)
}
xm+ym
sqrt(xm+ym)
min(sqrt(xm+ym))
sqrt(xm+ym)
roc.obj$sensitivities
roc.obj$sensitivities[12]
th.coef <- roc.obj$sensitivities + (roc.obj$specificities)
th.coef
th.sum <- roc.obj$sensitivities + (roc.obj$specificities)
which(th.sum %in% max(th.sum))
roc.obj$thresholds[3]
th.sum
th.sum <- roc.obj$sensitivities + roc.obj$specificities
th.sum
max(th.sum)
which(th.sum %in% max(th.sum))
roc.obj$thresholds[3]
roc.obj$thresholds[9]
roc.obj$thresholds[3]
roc.obj$thresholds[2]
roc.obj$thresholds[9]
th.index <- which(th.sum %in% max(th.sum))
ptest <- as.numeric(pp > 0.3)
cm <- caret::confusionMatrix(data = as.factor(ptest), reference = as.factor(labels))
cm$overall
ptest <- as.numeric(pp > 0.22)
cm <- caret::confusionMatrix(data = as.factor(ptest), reference = as.factor(labels))
cm$overall
# Calculate the Threshold Automatically
th.sum <- roc.obj$sensitivities + roc.obj$specificities
th.index <- which(th.sum %in% max(th.sum))
th.index
roc.obj$thresholds[th.index]
thrs <- roc.obj$thresholds[th.index]
ptest <- as.numeric(pp > thrs)
cm <- caret::confusionMatrix(data = as.factor(ptest), reference = as.factor(labels))
cm$overall
pROC::plot.roc(rocobj, print.auc = TRUE, main = "ROC-AUC Curve of a Logistic Regression model \n for the log(Alistipes/Parabacteroides) Ratio",
cex.axis = 1.8, cex.lab = 1.8, cex.main = 1.3, col = "red") # Smooth ROC AUC Curve
#### Log AP Ratio Marker ####
# Test the predictive power of the ratio of log10(Alistipes_indistinctus/Parabacteroides_distasonis)
path <- "../datasets/ratio.xlsx" # This is your file with your ratios
mb.data <- readxl::read_excel(path)
# Transform character data into numeric (binary 0,1)
mb.data$response[mb.data$response %in% "G"] <- 0 # Growth is coded as 0
mb.data$response[mb.data$response %in% "R"] <- 1 # Reduction is coded as 1
mb.data$response <- as.numeric(mb.data$response) # Ensure numbers are actually numeric data types
names(mb.data)[3] <- "ratio_alistipes_parabacteroides" # Name the column
path <- "../datasets/hrd/hrd_marker.xlsx"
hrd.data <- readxl::read_excel(path)
# Transform character data into numeric (binary 0,1)
hrd.data$response[hrd.data$response %in% "G"] <- 0 # Growth is coded as 0
hrd.data$response[hrd.data$response %in% "R"] <- 1 # Reduction is coded as 1
hrd.data$response <- as.numeric(hrd.data$response) # Ensure numbers are actually numeric data types
names(hrd.data)[3] <- "ratio_alistipes_parabacteroides" # Name the column
names(hrd.data)[7] <- "hrd_sum_marker" # Name the column
getZscore <- function(x, avg, dev) {
int.res <- x-avg
res <- int.res/dev
return(res)
}
dev <- sd(hrd.data$ratio_alistipes_parabacteroides)
avg <- mean(hrd.data$ratio_alistipes_parabacteroides)
ratio.z <- getZscore(hrd.data$ratio_alistipes_parabacteroides, avg, dev)
dev <- sd(hrd.data$hrd_sum_marker)
avg <- mean(hrd.data$hrd_sum_marker)
hrd.z <-getZscore(hrd.data$hrd_sum_marker, avg, dev)
dev <- sd(hrd.data$UPD)
avg <- mean(hrd.data$UPD)
upd.z <-getZscore(hrd.data$UPD, avg, dev)
hrd.data$ratio.z <- ratio.z
hrd.data$hrd.z <- hrd.z
hrd.data$upd.z <- upd.z
ratio_neg <- hrd.data$ratio_alistipes_parabacteroides * (-1)
hrd.data$cmb.mark <-ratio_neg + hrd.data$hrd_sum_marker + hrd.data$UPD
writexl::write_xlsx(hrd.data, "../datasets/biomarkers.xlsx")
log(hrd.data$ratio_alistipes_parabacteroides)
hrd.data$ratio_alistipes_parabacteroides <- log(hrd.data$ratio_alistipes_parabacteroides)
hrd.data
names(hrd.data)[3] <- "logratio_alistipes_parabacteroides" # Name the column
writexl::write_xlsx(hrd.data, "../datasets/biomarkers_v2.xlsx")
